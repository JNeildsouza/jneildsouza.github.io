<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Large Text Secure Chunking Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1, h2, h3 {
            text-align: center;
            color: #2c3e50;
        }
        .container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
        }
        .input-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        textarea {
            width: 100%;
            height: 300px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
            font-size: 14px;
            tab-size: 4;
            white-space: pre;
        }
        input[type="text"], input[type="number"], input[type="password"] {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button.danger {
            background-color: #e74c3c;
        }
        button.danger:hover {
            background-color: #c0392b;
        }
        button.success {
            background-color: #2ecc71;
        }
        button.success:hover {
            background-color: #27ae60;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .mode-toggle {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }
        .mode-button {
            background-color: #ecf0f1;
            color: #7f8c8d;
            border: 1px solid #ddd;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }
        .mode-button:hover {
            background-color: #d5dbdb;
        }
        .mode-button.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        .chunk-list {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 20px;
            padding: 10px;
        }
        .chunk-item {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            background-color: #f9f9f9;
        }
        .chunk-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }
        .chunk-data {
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 10px;
            font-family: monospace;
            box-sizing: border-box;
            background-color: #f5f5f5;
            resize: none;
            font-size: 12px;
            white-space: pre;
            overflow: auto;
        }
        .notification {
            background-color: #d4edda;
            color: #155724;
            padding: 10px 15px;
            border-radius: 4px;
            margin-top: 10px;
            text-align: center;
            display: none;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 10px 15px;
            border-radius: 4px;
            margin-top: 10px;
            text-align: center;
            display: none;
        }
        .info-box {
            background-color: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }
        .progress-container {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
        .copy-button {
            background-color: #7f8c8d;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .copy-button:hover {
            background-color: #6c7a7d;
        }
        .copy-all-button {
            background-color: #34495e;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        .copy-all-button:hover {
            background-color: #2c3e50;
        }
        .processing-indicator {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .loading-spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 4px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: #3498db;
            animation: spinner 1s linear infinite;
            margin-right: 10px;
        }
        .status-text {
            font-weight: bold;
            font-size: 16px;
            margin-left: 10px;
        }
        @keyframes spinner {
            to {transform: rotate(360deg);}
        }
        #output-view {
            width: 100%;
            height: 500px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            box-sizing: border-box;
            background-color: #f5f5f5;
            white-space: pre;
            overflow: auto;
            tab-size: 4;
            font-size: 14px;
            line-height: 1.5;
            display: none;
        }
        .password-validation {
            padding: 8px;
            margin-top: 5px;
            border-radius: 4px;
            font-size: 14px;
            display: none;
        }
        .validation-success {
            background-color: #d4edda;
            color: #155724;
        }
        .validation-error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .chunk-container {
            margin-top: 10px;
        }
        .memory-warning {
            font-size: 12px;
            color: #856404;
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            padding: 5px 10px;
            border-radius: 4px;
            margin-top: 5px;
        }
        .options-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .option-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>
<body>
    <h1>Large Text Secure Chunking Tool</h1>
    <p style="text-align: center; margin-bottom: 30px;">Securely split and reassemble large files (100K+ lines of code) while preserving exact formatting</p>
    
    <div class="mode-toggle">
        <button class="mode-button active" id="sender-mode-btn" onclick="switchMode('sender')">Encrypt & Split</button>
        <button class="mode-button" id="receiver-mode-btn" onclick="switchMode('receiver')">Reassemble & Decrypt</button>
    </div>
    
    <!-- SENDER MODE -->
    <div id="sender-mode" class="tab-content active">
        <div class="container">
            <h2>Split & Encrypt Large Text</h2>
            <div class="info-box">
                <p>This tool can handle extremely large texts (100K+ lines) by splitting them into encrypted chunks while preserving all formatting, indentation, and whitespace.</p>
                
                <div class="options-row">
                    <div class="option-group">
                        <label for="chunk-size">Characters per chunk:</label>
                        <input type="number" id="chunk-size" value="6000" min="1000" max="8000" style="width: 100px;">
                    </div>
                    
                    <div class="option-group">
                        <span style="margin-right: 10px;">Optimization:</span>
                        <select id="optimization-level">
                            <option value="balanced">Balanced (default)</option>
                            <option value="speed">Speed (for very large files)</option>
                            <option value="size">Size (smaller chunks)</option>
                        </select>
                    </div>
                </div>
                
                <input type="password" id="encrypt-password" placeholder="Enter password for encryption (required)" style="width: 100%;">
                <textarea id="input-text" placeholder="Paste your large text or code here (can handle 100K+ lines)..."></textarea>
                <div class="memory-warning">Large texts (>100K lines) may use significant memory. For best performance, use "Speed" optimization for very large files.</div>
                
                <div class="controls">
                    <button id="encrypt-button" class="success" onclick="splitAndEncrypt()">Encrypt & Generate Chunks</button>
                    <button id="clear-button" class="danger" onclick="clearSenderInputs()">Clear</button>
                </div>
                
                <div class="processing-indicator" id="encryption-progress">
                    <div class="loading-spinner"></div>
                    <span class="status-text">Processing large text...</span>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar" id="encryption-progress-bar"></div>
                </div>
                
                <div class="error" id="sender-error"></div>
            </div>
            
            <div id="chunks-output" style="display: none;">
                <div class="chunk-container">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <h3>Encrypted Chunks</h3>
                        <button class="copy-all-button" onclick="copyAllChunks()">Copy All Chunks</button>
                    </div>
                    
                    <p>Share these chunks with the recipient. They will need all chunks and your password to reassemble the original text.</p>
                    
                    <div class="notification" id="copy-notification">Copied to clipboard!</div>
                    
                    <div class="chunk-list" id="chunks-list"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- RECEIVER MODE -->
    <div id="receiver-mode" class="tab-content">
        <div class="container">
            <h2>Reassemble & Decrypt Large Text</h2>
            <div class="info-box">
                <p>Paste the encrypted chunks in any order. The tool will automatically validate and reassemble them into the original text.</p>
                
                <textarea id="chunk-input" placeholder="Paste an encrypted chunk here..."></textarea>
                
                <div class="controls">
                    <button id="add-chunk-button" onclick="validateAndAddChunk()">Add Chunk</button>
                    <button id="clear-chunks-button" class="danger" onclick="clearReceiverInputs()">Clear All</button>
                </div>
                
                <div class="password-validation" id="password-validation"></div>
                
                <div class="error" id="receiver-error"></div>
                
                <div class="progress-container">
                    <div class="progress-bar" id="reassembly-progress-bar"></div>
                </div>
                
                <div id="chunks-status" style="margin-top: 10px; font-weight: bold;">No chunks added yet</div>
                
                <input type="password" id="decrypt-password" placeholder="Enter decryption password" style="width: 100%; margin-top: 15px;">
                
                <div class="controls">
                    <button id="decrypt-button" class="success" onclick="reassembleAndDecrypt()" disabled>Decrypt & Reassemble All</button>
                </div>
                
                <div class="processing-indicator" id="decryption-progress">
                    <div class="loading-spinner"></div>
                    <span class="status-text">Reassembling and decrypting chunks...</span>
                </div>
            </div>
            
            <div id="output-container" style="display: none;">
                <h3>Reassembled Content</h3>
                
                <div class="controls">
                    <button class="copy-button" onclick="copyOutput()">Copy All</button>
                    <button class="success" onclick="downloadOutput()">Download as File</button>
                </div>
                
                <div class="notification" id="output-notification">Copied to clipboard!</div>
                
                <pre id="output-view"></pre>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let chunks = [];
        let receivedChunks = {};
        let totalChunks = 0;
        let sessionId = '';
        let decryptedContent = '';
        
        // Switch between sender and receiver modes
        function switchMode(mode) {
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(mode + '-mode-btn').classList.add('active');
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(mode + '-mode').classList.add('active');
            
            hideElement('sender-error');
            hideElement('receiver-error');
        }
        
        // Split and encrypt large text
        function splitAndEncrypt() {
            const text = document.getElementById('input-text').value;
            const password = document.getElementById('encrypt-password').value;
            const chunkSize = parseInt(document.getElementById('chunk-size').value);
            const optimization = document.getElementById('optimization-level').value;
            
            // Validation
            if (!text.trim()) {
                showError('Please enter text to encrypt.', 'sender-error');
                return;
            }
            
            if (!password) {
                showError('Please enter a password for encryption.', 'sender-error');
                return;
            }
            
            if (isNaN(chunkSize) || chunkSize < 1000 || chunkSize > 8000) {
                showError('Chunk size must be between 1000 and 8000 characters.', 'sender-error');
                return;
            }
            
            // Show processing indicator
            showElement('encryption-progress');
            document.getElementById('encrypt-button').disabled = true;
            hideElement('sender-error');
            
            // Clear previous chunks
            chunks = [];
            hideElement('chunks-output');
            
            // Use setTimeout to prevent UI blocking
            setTimeout(() => {
                try {
                    // Generate a session ID for this set of chunks
                    sessionId = generateSessionId();
                    
                    // Calculate effective chunk size based on optimization setting
                    let effectiveChunkSize = chunkSize;
                    if (optimization === 'size') {
                        effectiveChunkSize = Math.floor(chunkSize * 0.6); // Smaller chunks
                    } else if (optimization === 'speed') {
                        effectiveChunkSize = Math.floor(chunkSize * 0.8); // Larger chunks, fewer operations
                    } else {
                        effectiveChunkSize = Math.floor(chunkSize * 0.7); // Balanced
                    }
                    
                    // Calculate total chunks and initialize progress
                    const totalChunksToCreate = Math.ceil(text.length / effectiveChunkSize);
                    updateProgressBar('encryption-progress-bar', 0);
                    
                    // Use chunked processing to handle very large texts
                    processChunks(text, effectiveChunkSize, password, totalChunksToCreate, sessionId, 0);
                    
                } catch (error) {
                    console.error('Error during encryption:', error);
                    showError('Error during encryption: ' + error.message, 'sender-error');
                    hideElement('encryption-progress');
                    document.getElementById('encrypt-button').disabled = false;
                }
            }, 50);
        }
        
        // Process chunks incrementally to avoid blocking UI
        function processChunks(text, chunkSize, password, totalChunks, sessionId, startIndex) {
            if (startIndex >= text.length) {
                // All chunks processed
                showChunks();
                hideElement('encryption-progress');
                document.getElementById('encrypt-button').disabled = false;
                updateProgressBar('encryption-progress-bar', 100);
                return;
            }
            
            // Process one chunk
            const endIndex = Math.min(startIndex + chunkSize, text.length);
            const chunkText = text.substring(startIndex, endIndex);
            
            // Create chunk object with metadata
            const chunkObject = {
                id: sessionId,
                index: chunks.length + 1,
                total: totalChunks,
                text: chunkText
            };
            
            // Encrypt the chunk
            try {
                const encryptedChunk = encryptData(JSON.stringify(chunkObject), password);
                
                // Add formatted chunk
                const formattedChunk = `-----BEGIN ENCRYPTED CHUNK-----\n${encryptedChunk}\n-----END ENCRYPTED CHUNK-----`;
                chunks.push(formattedChunk);
                
                // Update progress
                const progress = Math.round((chunks.length / totalChunks) * 100);
                updateProgressBar('encryption-progress-bar', progress);
                
                // Schedule next chunk processing
                setTimeout(() => {
                    processChunks(text, chunkSize, password, totalChunks, sessionId, endIndex);
                }, 0);
                
            } catch (error) {
                console.error('Error encrypting chunk:', error);
                showError('Error encrypting chunk: ' + error.message, 'sender-error');
                hideElement('encryption-progress');
                document.getElementById('encrypt-button').disabled = false;
            }
        }
        
        // Show the encrypted chunks
        function showChunks() {
            const chunksListElement = document.getElementById('chunks-list');
            chunksListElement.innerHTML = '';
            
            chunks.forEach((chunk, index) => {
                const chunkDiv = document.createElement('div');
                chunkDiv.className = 'chunk-item';
                
                const headerDiv = document.createElement('div');
                headerDiv.className = 'chunk-header';
                headerDiv.textContent = `Chunk ${index + 1} of ${chunks.length}`;
                
                const textarea = document.createElement('textarea');
                textarea.className = 'chunk-data';
                textarea.value = chunk;
                textarea.readOnly = true;
                textarea.id = `chunk-${index + 1}`;
                
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-button';
                copyButton.textContent = 'Copy Chunk';
                copyButton.onclick = function() {
                    copyToClipboard(textarea.value);
                    showNotification('copy-notification');
                };
                
                const buttonDiv = document.createElement('div');
                buttonDiv.style.textAlign = 'right';
                buttonDiv.style.marginTop = '10px';
                buttonDiv.appendChild(copyButton);
                
                chunkDiv.appendChild(headerDiv);
                chunkDiv.appendChild(textarea);
                chunkDiv.appendChild(buttonDiv);
                
                chunksListElement.appendChild(chunkDiv);
            });
            
            showElement('chunks-output');
        }
        
        // Copy all chunks to clipboard
        function copyAllChunks() {
            const allChunks = chunks.join('\n\n');
            copyToClipboard(allChunks);
            showNotification('copy-notification');
        }
        
        // Validate and add a chunk for reassembly
        function validateAndAddChunk() {
            const chunkText = document.getElementById('chunk-input').value.trim();
            
            if (!chunkText) {
                showError('Please paste an encrypted chunk.', 'receiver-error');
                return;
            }
            
            // Extract the chunk data
            const match = chunkText.match(/-----BEGIN ENCRYPTED CHUNK-----([\s\S]*?)-----END ENCRYPTED CHUNK-----/);
            if (!match || !match[1]) {
                showError('Invalid chunk format. Please paste the complete chunk including BEGIN and END markers.', 'receiver-error');
                return;
            }
            
            const encryptedData = match[1].trim();
            
            try {
                // Extract metadata from the chunk
                const metadata = extractChunkMetadata(encryptedData);
                
                if (!metadata || !metadata.id || !metadata.index || !metadata.total) {
                    showError('Invalid chunk data. Unable to extract chunk information.', 'receiver-error');
                    return;
                }
                
                // Initialize if first chunk
                if (!sessionId) {
                    sessionId = metadata.id;
                    totalChunks = metadata.total;
                    receivedChunks = {};
                } else if (sessionId !== metadata.id) {
                    showError('This chunk belongs to a different session. Please clear all chunks first.', 'receiver-error');
                    return;
                }
                
                // Store the chunk
                receivedChunks[metadata.index] = encryptedData;
                
                // Update the UI
                updateReassemblyProgress();
                
                // Clear the input
                document.getElementById('chunk-input').value = '';
                hideElement('receiver-error');
                
                // Validate password if it's entered
                const password = document.getElementById('decrypt-password').value;
                if (password) {
                    validatePassword(encryptedData, password);
                }
                
                // Enable decrypt button if all chunks received
                const receivedCount = Object.keys(receivedChunks).length;
                if (receivedCount === totalChunks) {
                    document.getElementById('decrypt-button').disabled = false;
                }
                
            } catch (error) {
                console.error('Error processing chunk:', error);
                showError('Error processing chunk: ' + error.message, 'receiver-error');
            }
        }
        
        // Update reassembly progress
        function updateReassemblyProgress() {
            const receivedCount = Object.keys(receivedChunks).length;
            const progress = Math.round((receivedCount / totalChunks) * 100);
            
            updateProgressBar('reassembly-progress-bar', progress);
            
            const statusElement = document.getElementById('chunks-status');
            statusElement.innerHTML = `Received ${receivedCount} of ${totalChunks} chunks for session: <span style="color: #3498db;">${sessionId}</span>`;
            
            // List missing chunks if any
            if (receivedCount < totalChunks) {
                const missing = [];
                for (let i = 1; i <= totalChunks; i++) {
                    if (!receivedChunks[i]) {
                        missing.push(i);
                    }
                }
                
                if (missing.length > 0) {
                    let missingText = missing.length > 10 
                        ? `Missing chunks: ${missing.slice(0, 10).join(', ')}... and ${missing.length - 10} more`
                        : `Missing chunks: ${missing.join(', ')}`;
                    
                    statusElement.innerHTML += `<br><span style="color: #e74c3c;">${missingText}</span>`;
                }
            } else {
                statusElement.innerHTML += '<br><span style="color: #2ecc71;">All chunks received! Ready to decrypt.</span>';
            }
        }
        
        // Validate the password for real-time feedback
        function validatePassword(encryptedData, password) {
            try {
                // Try to decrypt one chunk to validate password
                const decrypted = decryptData(encryptedData, password);
                const data = JSON.parse(decrypted);
                
                if (data && data.id && data.text) {
                    // Password is valid
                    const validationElement = document.getElementById('password-validation');
                    validationElement.textContent = 'Password is valid! ✓';
                    validationElement.className = 'password-validation validation-success';
                    showElement('password-validation');
                    return true;
                }
            } catch (error) {
                // Password is invalid
                const validationElement = document.getElementById('password-validation');
                validationElement.textContent = 'Invalid password! ✗';
                validationElement.className = 'password-validation validation-error';
                showElement('password-validation');
                return false;
            }
            
            return false;
        }
        
        // Reassemble and decrypt all chunks
        function reassembleAndDecrypt() {
            const password = document.getElementById('decrypt-password').value;
            
            if (!password) {
                showError('Please enter the decryption password.', 'receiver-error');
                return;
            }
            
            // Validate password before proceeding
            const firstChunkIndex = Object.keys(receivedChunks)[0];
            const firstChunk = receivedChunks[firstChunkIndex];
            
            if (!validatePassword(firstChunk, password)) {
                showError('Invalid password. Please check and try again.', 'receiver-error');
                return;
            }
            
            // Check if we have all chunks
            const receivedCount = Object.keys(receivedChunks).length;
            if (receivedCount < totalChunks) {
                showError(`Missing chunks. Only ${receivedCount} of ${totalChunks} chunks received.`, 'receiver-error');
                return;
            }
            
            // Show processing indicator
            showElement('decryption-progress');
            document.getElementById('decrypt-button').disabled = true;
            hideElement('receiver-error');
            hideElement('output-container');
            
            // Use setTimeout to prevent UI blocking
            setTimeout(() => {
                try {
                    // Decrypt all chunks incrementally
                    decryptChunks(password, 1);
                } catch (error) {
                    console.error('Error during decryption:', error);
                    showError('Error during decryption: ' + error.message, 'receiver-error');
                    hideElement('decryption-progress');
                    document.getElementById('decrypt-button').disabled = false;
                }
            }, 50);
        }
        
        // Decrypt chunks incrementally
        function decryptChunks(password, currentIndex) {
            if (currentIndex > totalChunks) {
                // All chunks decrypted, show output
                document.getElementById('output-view').textContent = decryptedContent;
                showElement('output-container');
                showElement('output-view');
                hideElement('decryption-progress');
                document.getElementById('decrypt-button').disabled = false;
                return;
            }
            
            // Process one chunk
            try {
                const encryptedData = receivedChunks[currentIndex];
                if (!encryptedData) {
                    showError(`Missing chunk ${currentIndex}.`, 'receiver-error');
                    hideElement('decryption-progress');
                    document.getElementById('decrypt-button').disabled = false;
                    return;
                }
                
                // Decrypt the chunk
                const decrypted = decryptData(encryptedData, password);
                const chunkObject = JSON.parse(decrypted);
                
                // Verify chunk order
                if (chunkObject.index !== currentIndex) {
                    showError(`Chunk order mismatch. Expected index ${currentIndex} but found ${chunkObject.index}.`, 'receiver-error');
                    hideElement('decryption-progress');
                    document.getElementById('decrypt-button').disabled = false;
                    return;
                }
                
                // Append to decrypted content
                if (currentIndex === 1) {
                    decryptedContent = chunkObject.text;
                } else {
                    decryptedContent += chunkObject.text;
                }
                
                // Update progress
                const progress = Math.round((currentIndex / totalChunks) * 100);
                document.querySelector('#decryption-progress .status-text').textContent = 
                    `Reassembling and decrypting chunks... ${currentIndex}/${totalChunks}`;
                
                // Schedule next chunk processing
                setTimeout(() => {
                    decryptChunks(password, currentIndex + 1);
                }, 0);

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Large Text Secure Chunking Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1, h2, h3 {
            text-align: center;
            color: #2c3e50;
        }
        .container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
        }
        .input-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        textarea {
            width: 100%;
            height: 300px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
            font-size: 14px;
            tab-size: 4;
            white-space: pre;
        }
        input[type="text"], input[type="number"], input[type="password"] {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button.danger {
            background-color: #e74c3c;
        }
        button.danger:hover {
            background-color: #c0392b;
        }
        button.success {
            background-color: #2ecc71;
        }
        button.success:hover {
            background-color: #27ae60;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .mode-toggle {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }
        .mode-button {
            background-color: #ecf0f1;
            color: #7f8c8d;
            border: 1px solid #ddd;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }
        .mode-button:hover {
            background-color: #d5dbdb;
        }
        .mode-button.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        .chunk-list {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 20px;
            padding: 10px;
        }
        .chunk-item {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            background-color: #f9f9f9;
        }
        .chunk-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }
        .chunk-data {
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 10px;
            font-family: monospace;
            box-sizing: border-box;
            background-color: #f5f5f5;
            resize: none;
            font-size: 12px;
            white-space: pre;
            overflow: auto;
        }
        .notification {
            background-color: #d4edda;
            color: #155724;
            padding: 10px 15px;
            border-radius: 4px;
            margin-top: 10px;
            text-align: center;
            display: none;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 10px 15px;
            border-radius: 4px;
            margin-top: 10px;
            text-align: center;
            display: none;
        }
        .info-box {
            background-color: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }
        .progress-container {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
        .copy-button {
            background-color: #7f8c8d;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .copy-button:hover {
            background-color: #6c7a7d;
        }
        .copy-all-button {
            background-color: #34495e;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        .copy-all-button:hover {
            background-color: #2c3e50;
        }
        .processing-indicator {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .loading-spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 4px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: #3498db;
            animation: spinner 1s linear infinite;
            margin-right: 10px;
        }
        .status-text {
            font-weight: bold;
            font-size: 16px;
            margin-left: 10px;
        }
        @keyframes spinner {
            to {transform: rotate(360deg);}
        }
        #output-view {
            width: 100%;
            height: 500px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            box-sizing: border-box;
            background-color: #f5f5f5;
            white-space: pre;
            overflow: auto;
            tab-size: 4;
            font-size: 14px;
            line-height: 1.5;
            display: none;
        }
        .password-validation {
            padding: 8px;
            margin-top: 5px;
            border-radius: 4px;
            font-size: 14px;
            display: none;
        }
        .validation-success {
            background-color: #d4edda;
            color: #155724;
        }
        .validation-error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .chunk-container {
            margin-top: 10px;
        }
        .memory-warning {
            font-size: 12px;
            color: #856404;
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            padding: 5px 10px;
            border-radius: 4px;
            margin-top: 5px;
        }
        .options-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .option-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>
<body>
    <h1>Large Text Secure Chunking Tool</h1>
    <p style="text-align: center; margin-bottom: 30px;">Securely split and reassemble large files (100K+ lines of code) while preserving exact formatting</p>
    
    <div class="mode-toggle">
        <button class="mode-button active" id="sender-mode-btn" onclick="switchMode('sender')">Encrypt & Split</button>
        <button class="mode-button" id="receiver-mode-btn" onclick="switchMode('receiver')">Reassemble & Decrypt</button>
    </div>
    
    <!-- SENDER MODE -->
    <div id="sender-mode" class="tab-content active">
        <div class="container">
            <h2>Split & Encrypt Large Text</h2>
            <div class="info-box">
                <p>This tool can handle extremely large texts (100K+ lines) by splitting them into encrypted chunks while preserving all formatting, indentation, and whitespace.</p>
                
                <div class="options-row">
                    <div class="option-group">
                        <label for="chunk-size">Characters per chunk:</label>
                        <input type="number" id="chunk-size" value="6000" min="1000" max="8000" style="width: 100px;">
                    </div>
                    
                    <div class="option-group">
                        <span style="margin-right: 10px;">Optimization:</span>
                        <select id="optimization-level">
                            <option value="balanced">Balanced (default)</option>
                            <option value="speed">Speed (for very large files)</option>
                            <option value="size">Size (smaller chunks)</option>
                        </select>
                    </div>
                </div>
                
                <input type="password" id="encrypt-password" placeholder="Enter password for encryption (required)" style="width: 100%;">
                <textarea id="input-text" placeholder="Paste your large text or code here (can handle 100K+ lines)..."></textarea>
                <div class="memory-warning">Large texts (>100K lines) may use significant memory. For best performance, use "Speed" optimization for very large files.</div>
                
                <div class="controls">
                    <button id="encrypt-button" class="success" onclick="splitAndEncrypt()">Encrypt & Generate Chunks</button>
                    <button id="clear-button" class="danger" onclick="clearSenderInputs()">Clear</button>
                </div>
                
                <div class="processing-indicator" id="encryption-progress">
                    <div class="loading-spinner"></div>
                    <span class="status-text">Processing large text...</span>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar" id="encryption-progress-bar"></div>
                </div>
                
                <div class="error" id="sender-error"></div>
            </div>
            
            <div id="chunks-output" style="display: none;">
                <div class="chunk-container">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <h3>Encrypted Chunks</h3>
                        <button class="copy-all-button" onclick="copyAllChunks()">Copy All Chunks</button>
                    </div>
                    
                    <p>Share these chunks with the recipient. They will need all chunks and your password to reassemble the original text.</p>
                    
                    <div class="notification" id="copy-notification">Copied to clipboard!</div>
                    
                    <div class="chunk-list" id="chunks-list"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- RECEIVER MODE -->
    <div id="receiver-mode" class="tab-content">
        <div class="container">
            <h2>Reassemble & Decrypt Large Text</h2>
            <div class="info-box">
                <p>Paste the encrypted chunks in any order. The tool will automatically validate and reassemble them into the original text.</p>
                
                <textarea id="chunk-input" placeholder="Paste an encrypted chunk here..."></textarea>
                
                <div class="controls">
                    <button id="add-chunk-button" onclick="validateAndAddChunk()">Add Chunk</button>
                    <button id="clear-chunks-button" class="danger" onclick="clearReceiverInputs()">Clear All</button>
                </div>
                
                <div class="password-validation" id="password-validation"></div>
                
                <div class="error" id="receiver-error"></div>
                
                <div class="progress-container">
                    <div class="progress-bar" id="reassembly-progress-bar"></div>
                </div>
                
                <div id="chunks-status" style="margin-top: 10px; font-weight: bold;">No chunks added yet</div>
                
                <input type="password" id="decrypt-password" placeholder="Enter decryption password" style="width: 100%; margin-top: 15px;">
                
                <div class="controls">
                    <button id="decrypt-button" class="success" onclick="reassembleAndDecrypt()" disabled>Decrypt & Reassemble All</button>
                </div>
                
                <div class="processing-indicator" id="decryption-progress">
                    <div class="loading-spinner"></div>
                    <span class="status-text">Reassembling and decrypting chunks...</span>
                </div>
            </div>
            
            <div id="output-container" style="display: none;">
                <h3>Reassembled Content</h3>
                
                <div class="controls">
                    <button class="copy-button" onclick="copyOutput()">Copy All</button>
                    <button class="success" onclick="downloadOutput()">Download as File</button>
                </div>
                
                <div class="notification" id="output-notification">Copied to clipboard!</div>
                
                <pre id="output-view"></pre>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let chunks = [];
        let receivedChunks = {};
        let totalChunks = 0;
        let sessionId = '';
        let decryptedContent = '';
        
        // Switch between sender and receiver modes
        function switchMode(mode) {
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(mode + '-mode-btn').classList.add('active');
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(mode + '-mode').classList.add('active');
            
            hideElement('sender-error');
            hideElement('receiver-error');
        }
        
        // Split and encrypt large text
        function splitAndEncrypt() {
            const text = document.getElementById('input-text').value;
            const password = document.getElementById('encrypt-password').value;
            const chunkSize = parseInt(document.getElementById('chunk-size').value);
            const optimization = document.getElementById('optimization-level').value;
            
            // Validation
            if (!text.trim()) {
                showError('Please enter text to encrypt.', 'sender-error');
                return;
            }
            
            if (!password) {
                showError('Please enter a password for encryption.', 'sender-error');
                return;
            }
            
            if (isNaN(chunkSize) || chunkSize < 1000 || chunkSize > 8000) {
                showError('Chunk size must be between 1000 and 8000 characters.', 'sender-error');
                return;
            }
            
            // Show processing indicator
            showElement('encryption-progress');
            document.getElementById('encrypt-button').disabled = true;
            hideElement('sender-error');
            
            // Clear previous chunks
            chunks = [];
            hideElement('chunks-output');
            
            // Use setTimeout to prevent UI blocking
            setTimeout(() => {
                try {
                    // Generate a session ID for this set of chunks
                    sessionId = generateSessionId();
                    
                    // Calculate effective chunk size based on optimization setting
                    let effectiveChunkSize = chunkSize;
                    if (optimization === 'size') {
                        effectiveChunkSize = Math.floor(chunkSize * 0.6); // Smaller chunks
                    } else if (optimization === 'speed') {
                        effectiveChunkSize = Math.floor(chunkSize * 0.8); // Larger chunks, fewer operations
                    } else {
                        effectiveChunkSize = Math.floor(chunkSize * 0.7); // Balanced
                    }
                    
                    // Calculate total chunks and initialize progress
                    const totalChunksToCreate = Math.ceil(text.length / effectiveChunkSize);
                    updateProgressBar('encryption-progress-bar', 0);
                    
                    // Use chunked processing to handle very large texts
                    processChunks(text, effectiveChunkSize, password, totalChunksToCreate, sessionId, 0);
                    
                } catch (error) {
                    console.error('Error during encryption:', error);
                    showError('Error during encryption: ' + error.message, 'sender-error');
                    hideElement('encryption-progress');
                    document.getElementById('encrypt-button').disabled = false;
                }
            }, 50);
        }
        
        // Process chunks incrementally to avoid blocking UI
        function processChunks(text, chunkSize, password, totalChunks, sessionId, startIndex) {
            if (startIndex >= text.length) {
                // All chunks processed
                showChunks();
                hideElement('encryption-progress');
                document.getElementById('encrypt-button').disabled = false;
                updateProgressBar('encryption-progress-bar', 100);
                return;
            }
            
            // Process one chunk
            const endIndex = Math.min(startIndex + chunkSize, text.length);
            const chunkText = text.substring(startIndex, endIndex);
            
            // Create chunk object with metadata
            const chunkObject = {
                id: sessionId,
                index: chunks.length + 1,
                total: totalChunks,
                text: chunkText
            };
            
            // Encrypt the chunk
            try {
                const encryptedChunk = encryptData(JSON.stringify(chunkObject), password);
                
                // Add formatted chunk
                const formattedChunk = `-----BEGIN ENCRYPTED CHUNK-----\n${encryptedChunk}\n-----END ENCRYPTED CHUNK-----`;
                chunks.push(formattedChunk);
                
                // Update progress
                const progress = Math.round((chunks.length / totalChunks) * 100);
                updateProgressBar('encryption-progress-bar', progress);
                
                // Schedule next chunk processing
                setTimeout(() => {
                    processChunks(text, chunkSize, password, totalChunks, sessionId, endIndex);
                }, 0);
                
            } catch (error) {
                console.error('Error encrypting chunk:', error);
                showError('Error encrypting chunk: ' + error.message, 'sender-error');
                hideElement('encryption-progress');
                document.getElementById('encrypt-button').disabled = false;
            }
        }
        
        // Show the encrypted chunks
        function showChunks() {
            const chunksListElement = document.getElementById('chunks-list');
            chunksListElement.innerHTML = '';
            
            chunks.forEach((chunk, index) => {
                const chunkDiv = document.createElement('div');
                chunkDiv.className = 'chunk-item';
                
                const headerDiv = document.createElement('div');
                headerDiv.className = 'chunk-header';
                headerDiv.textContent = `Chunk ${index + 1} of ${chunks.length}`;
                
                const textarea = document.createElement('textarea');
                textarea.className = 'chunk-data';
                textarea.value = chunk;
                textarea.readOnly = true;
                textarea.id = `chunk-${index + 1}`;
                
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-button';
                copyButton.textContent = 'Copy Chunk';
                copyButton.onclick = function() {
                    copyToClipboard(textarea.value);
                    showNotification('copy-notification');
                };
                
                const buttonDiv = document.createElement('div');
                buttonDiv.style.textAlign = 'right';
                buttonDiv.style.marginTop = '10px';
                buttonDiv.appendChild(copyButton);
                
                chunkDiv.appendChild(headerDiv);
                chunkDiv.appendChild(textarea);
                chunkDiv.appendChild(buttonDiv);
                
                chunksListElement.appendChild(chunkDiv);
            });
            
            showElement('chunks-output');
        }
        
        // Copy all chunks to clipboard
        function copyAllChunks() {
            const allChunks = chunks.join('\n\n');
            copyToClipboard(allChunks);
            showNotification('copy-notification');
        }
        
        // Validate and add a chunk for reassembly
        function validateAndAddChunk() {
            const chunkText = document.getElementById('chunk-input').value.trim();
            
            if (!chunkText) {
                showError('Please paste an encrypted chunk.', 'receiver-error');
                return;
            }
            
            // Extract the chunk data
            const match = chunkText.match(/-----BEGIN ENCRYPTED CHUNK-----([\s\S]*?)-----END ENCRYPTED CHUNK-----/);
            if (!match || !match[1]) {
                showError('Invalid chunk format. Please paste the complete chunk including BEGIN and END markers.', 'receiver-error');
                return;
            }
            
            const encryptedData = match[1].trim();
            
            try {
                // Extract metadata from the chunk
                const metadata = extractChunkMetadata(encryptedData);
                
                if (!metadata || !metadata.id || !metadata.index || !metadata.total) {
                    showError('Invalid chunk data. Unable to extract chunk information.', 'receiver-error');
                    return;
                }
                
                // Initialize if first chunk
                if (!sessionId) {
                    sessionId = metadata.id;
                    totalChunks = metadata.total;
                    receivedChunks = {};
                } else if (sessionId !== metadata.id) {
                    showError('This chunk belongs to a different session. Please clear all chunks first.', 'receiver-error');
                    return;
                }
                
                // Store the chunk
                receivedChunks[metadata.index] = encryptedData;
                
                // Update the UI
                updateReassemblyProgress();
                
                // Clear the input
                document.getElementById('chunk-input').value = '';
                hideElement('receiver-error');
                
                // Validate password if it's entered
                const password = document.getElementById('decrypt-password').value;
                if (password) {
                    validatePassword(encryptedData, password);
                }
                
                // Enable decrypt button if all chunks received
                const receivedCount = Object.keys(receivedChunks).length;
                if (receivedCount === totalChunks) {
                    document.getElementById('decrypt-button').disabled = false;
                }
                
            } catch (error) {
                console.error('Error processing chunk:', error);
                showError('Error processing chunk: ' + error.message, 'receiver-error');
            }
        }
        
        // Update reassembly progress
        function updateReassemblyProgress() {
            const receivedCount = Object.keys(receivedChunks).length;
            const progress = Math.round((receivedCount / totalChunks) * 100);
            
            updateProgressBar('reassembly-progress-bar', progress);
            
            const statusElement = document.getElementById('chunks-status');
            statusElement.innerHTML = `Received ${receivedCount} of ${totalChunks} chunks for session: <span style="color: #3498db;">${sessionId}</span>`;
            
            // List missing chunks if any
            if (receivedCount < totalChunks) {
                const missing = [];
                for (let i = 1; i <= totalChunks; i++) {
                    if (!receivedChunks[i]) {
                        missing.push(i);
                    }
                }
                
                if (missing.length > 0) {
                    let missingText = missing.length > 10 
                        ? `Missing chunks: ${missing.slice(0, 10).join(', ')}... and ${missing.length - 10} more`
                        : `Missing chunks: ${missing.join(', ')}`;
                    
                    statusElement.innerHTML += `<br><span style="color: #e74c3c;">${missingText}</span>`;
                }
            } else {
                statusElement.innerHTML += '<br><span style="color: #2ecc71;">All chunks received! Ready to decrypt.</span>';
            }
        }
        
        // Validate the password for real-time feedback
        function validatePassword(encryptedData, password) {
            try {
                // Try to decrypt one chunk to validate password
                const decrypted = decryptData(encryptedData, password);
                const data = JSON.parse(decrypted);
                
                if (data && data.id && data.text) {
                    // Password is valid
                    const validationElement = document.getElementById('password-validation');
                    validationElement.textContent = 'Password is valid! ✓';
                    validationElement.className = 'password-validation validation-success';
                    showElement('password-validation');
                    return true;
                }
            } catch (error) {
                // Password is invalid
                const validationElement = document.getElementById('password-validation');
                validationElement.textContent = 'Invalid password! ✗';
                validationElement.className = 'password-validation validation-error';
                showElement('password-validation');
                return false;
            }
            
            return false;
        }
        
        // Reassemble and decrypt all chunks
        function reassembleAndDecrypt() {
            const password = document.getElementById('decrypt-password').value;
            
            if (!password) {
                showError('Please enter the decryption password.', 'receiver-error');
                return;
            }
            
            // Validate password before proceeding
            const firstChunkIndex = Object.keys(receivedChunks)[0];
            const firstChunk = receivedChunks[firstChunkIndex];
            
            if (!validatePassword(firstChunk, password)) {
                showError('Invalid password. Please check and try again.', 'receiver-error');
                return;
            }
            
            // Check if we have all chunks
            const receivedCount = Object.keys(receivedChunks).length;
            if (receivedCount < totalChunks) {
                showError(`Missing chunks. Only ${receivedCount} of ${totalChunks} chunks received.`, 'receiver-error');
                return;
            }
            
            // Show processing indicator
            showElement('decryption-progress');
            document.getElementById('decrypt-button').disabled = true;
            hideElement('receiver-error');
            hideElement('output-container');
            
            // Use setTimeout to prevent UI blocking
            setTimeout(() => {
                try {
                    // Decrypt all chunks incrementally
                    decryptChunks(password, 1);
                } catch (error) {
                    console.error('Error during decryption:', error);
                    showError('Error during decryption: ' + error.message, 'receiver-error');
                    hideElement('decryption-progress');
                    document.getElementById('decrypt-button').disabled = false;
                }
            }, 50);
        }
        
        // Decrypt chunks incrementally
        function decryptChunks(password, currentIndex) {
            if (currentIndex > totalChunks) {
                // All chunks decrypted, show output
                document.getElementById('output-view').textContent = decryptedContent;
                showElement('output-container');
                showElement('output-view');
                hideElement('decryption-progress');
                document.getElementById('decrypt-button').disabled = false;
                return;
            }
            
            // Process one chunk
            try {
                const encryptedData = receivedChunks[currentIndex];
                if (!encryptedData) {
                    showError(`Missing chunk ${currentIndex}.`, 'receiver-error');
                    hideElement('decryption-progress');
                    document.getElementById('decrypt-button').disabled = false;
                    return;
                }
                
                // Decrypt the chunk
                const decrypted = decryptData(encryptedData, password);
                const chunkObject = JSON.parse(decrypted);
                
                // Verify chunk order
                if (chunkObject.index !== currentIndex) {
                    showError(`Chunk order mismatch. Expected index ${currentIndex} but found ${chunkObject.index}.`, 'receiver-error');
                    hideElement('decryption-progress');
                    document.getElementById('decrypt-button').disabled = false;
                    return;
                }
                
                // Append to decrypted content
                if (currentIndex === 1) {
                    decryptedContent = chunkObject.text;
                } else {
                    decryptedContent += chunkObject.text;
                }
                
                // Update progress
                const progress = Math.round((currentIndex / totalChunks) * 100);
                document.querySelector('#decryption-progress .status-text').textContent = 
                    `Reassembling and decrypting chunks... ${currentIndex}/${totalChunks}`;
                
                // Schedule next chunk processing
                setTimeout(() => {
                    decryptChunks(password, currentIndex + 1);
                }, 0);
                
            } catch (error) {
                console.error(`Error decrypting chunk ${currentIndex}:`, error);
                showError(`Error decrypting chunk ${currentIndex}: ${error.message}`, 'receiver-error');
                hideElement('decryption-progress');
                document.getElementById('decrypt-button').disabled = false;
            }
        }
        
        // Extract metadata from an encrypted chunk without decrypting the content
        function extractChunkMetadata(encryptedData) {
            try {
                // Create a dummy pattern to extract just the header portion
                const headerPattern = new Uint8Array(64); // First 64 bytes should contain header info
                const dummyPassword = "metadataOnly";
                const dummyBytes = new TextEncoder().encode(dummyPassword);
                
                // Decode the base64 data
                const data = atob(encryptedData);
                const bytes = new Uint8Array(data.length);
                for (let i = 0; i < data.length; i++) {
                    bytes[i] = data.charCodeAt(i);
                }
                
                // XOR only the first portion to try to get the metadata
                for (let i = 0; i < Math.min(headerPattern.length, bytes.length); i++) {
                    headerPattern[i] = bytes[i] ^ dummyBytes[i % dummyBytes.length];
                }
                
                // Try to interpret as JSON to get metadata fields
                const headerText = new TextDecoder().decode(headerPattern);
                const match = headerText.match(/"id":"([^"]+)","index":(\d+),"total":(\d+)/);
                
                if (match) {
                    return {
                        id: match[1],
                        index: parseInt(match[2]),
                        total: parseInt(match[3])
                    };
                }
                
                return null;
            } catch (error) {
                console.error('Error extracting metadata:', error);
                return null;
            }
        }
        
        // Copy output to clipboard
        function copyOutput() {
            copyToClipboard(document.getElementById('output-view').textContent);
            showNotification('output-notification');
        }
        
        // Download output as file
        function downloadOutput() {
            const content = document.getElementById('output-view').textContent;
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `decrypted_${sessionId}.txt`;
            a.click();
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
        }
        
        // Clear sender inputs
        function clearSenderInputs() {
            document.getElementById('input-text').value = '';
            document.getElementById('encrypt-password').value = '';
            document.getElementById('chunks-list').innerHTML = '';
            hideElement('chunks-output');
            hideElement('sender-error');
            updateProgressBar('encryption-progress-bar', 0);
            chunks = [];
        }
        
        // Clear receiver inputs
        function clearReceiverInputs() {
            document.getElementById('chunk-input').value = '';
            document.getElementById('decrypt-password').value = '';
            document.getElementById('chunks-status').textContent = 'No chunks added yet';
            hideElement('output-container');
            hideElement('receiver-error');
            hideElement('password-validation');
            updateProgressBar('reassembly-progress-bar', 0);
            document.getElementById('decrypt-button').disabled = true;
            receivedChunks = {};
            totalChunks = 0;
            sessionId = '';
            decryptedContent = '';
        }
        
        // Encrypt data
        function encryptData(data, password) {
            try {
                // Convert data and password to bytes
                const dataBytes = new TextEncoder().encode(data);
                const passwordBytes = new TextEncoder().encode(password);
                
                // Create encrypted array
                const encrypted = new Uint8Array(dataBytes.length);
                
                // XOR encryption
                for (let i = 0; i < dataBytes.length; i++) {
                    encrypted[i] = dataBytes[i] ^ passwordBytes[i % passwordBytes.length];
                }
                
                // Convert to base64 in chunks to avoid call stack issues
                return bufferToBase64(encrypted);
                
            } catch (error) {
                console.error('Encryption error:', error);
                throw new Error('Encryption failed: ' + error.message);
            }
        }
        
        // Decrypt data
        function decryptData(encryptedBase64, password) {
            try {
                // Decode base64
                const data = atob(encryptedBase64);
                const encryptedBytes = new Uint8Array(data.length);
                for (let i = 0; i < data.length; i++) {
                    encryptedBytes[i] = data.charCodeAt(i);
                }
                
                // Get password bytes
                const passwordBytes = new TextEncoder().encode(password);
                
                // Create decrypted array
                const decrypted = new Uint8Array(encryptedBytes.length);
                
                // XOR decryption (same as encryption)
                for (let i = 0; i < encryptedBytes.length; i++) {
                    decrypted[i] = encryptedBytes[i] ^ passwordBytes[i % passwordBytes.length];
                }
                
                // Convert to string
                return new TextDecoder().decode(decrypted);
                
            } catch (error) {
                console.error('Decryption error:', error);
                throw new Error('Decryption failed: ' + error.message);
            }
        }
        
        // Convert buffer to base64 in chunks
        function bufferToBase64(buffer) {
            // Process in chunks to avoid call stack size limit
            const CHUNK_SIZE = 32768; // 32KB chunks
            let result = '';
            
            for (let i = 0; i < buffer.length; i += CHUNK_SIZE) {
                const chunk = buffer.slice(i, Math.min(i + CHUNK_SIZE, buffer.length));
                const chunkString = String.fromCharCode.apply(null, chunk);
                result += chunkString;
            }
            
            return btoa(result);
        }
        
        // Copy text to clipboard
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).catch(err => {
                console.error('Could not copy: ', err);
                
                // Fallback method
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
            });
        }
        
        // Generate a random session ID
        function generateSessionId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < 8; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }
        
        // Update a progress bar
        function updateProgressBar(elementId, percentage) {
            document.getElementById(elementId).style.width = percentage + '%';
        }
        
        // Show an element
        function showElement(elementId) {
            document.getElementById(elementId).style.display = 'block';
        }
        
        // Hide an element
        function hideElement(elementId) {
            document.getElementById(elementId).style.display = 'none';
        }
        
        // Show an error
        function showError(message, elementId) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.style.display = 'block';
        }
        
        // Show a notification
        function showNotification(elementId) {
            const element = document.getElementById(elementId);
            element.style.display = 'block';
            setTimeout(() => {
                element.style.display = 'none';
            }, 2000);
        }
    </script>
</body>
</html>
